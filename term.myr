use std
use "termios"

pkg termdraw =
	type color = int
	type attr = int

	const Black	: color = 0
	const Red  	: color = 1
	const Green	: color = 2
	const Yellow	: color = 3
	const Blue 	: color = 4
	const Magenta	: color = 5
	const Cyan 	: color = 6
	const White	: color = 7
	const Default	: color = 9

	const Normal	: attr = 0
	const Bold	: attr = 1
	const Italic	: attr = 3
	const Underline	: attr = 4
	const Blink	: attr = 5
	const Invert	: attr = 7

	type term = struct
		fd	: std.fd
		x	: int
		y	: int
		cx	: int
		cy	: int
		width	: int
		height	: int
		fg	: color
		bg	: color
		attr	: attr
		buf	: cell[:]
		orig	: termios
		cursor	: bool
	;;

	type cell = struct
		chr	: char
		attr	: attr
		fg	: color
		bg	: color
	;;

	const mk	: (fd : std.fd -> term#)
	const free	: (t : term# -> void)
	const raw	: (t : term# -> void)

	const size	: (t : term# -> (int, int))
	const move	: (t : term#, r : int, c : int -> void)
	const cursorpos	: (t : term#, r : int, c : int -> void)
	const cursoroff	: (t : term# -> void)
	const cursoron	: (t : term# -> void)

	const cls	: (t : term# -> void)
	const clear	: (t : term#, x0 : int, y0 : int, x1 : int, y1 : int -> void)
	const flush	: (t : term# -> void)
	const putc	: (t : term#, c : char -> void)
	const put	: (t : term#, fmt : byte[:], args : ... -> void)
	const setfg	: (t : term#, c : color -> void)
	const setbg	: (t : term#, c : color -> void)
	const setattr	: (t : term#, c : attr -> void)

	pkglocal const resize	: (t : term#, x : int, y : int -> void)
;;

const mk = {fd
	var ws
	var t

	tcwinsize(fd, &ws)
	t = std.mk([
		.fd=fd,
		.x=0,
		.y=0,
		.width=(ws.col : int),
		.height=(ws.row: int),
		.fg=Default,
		.bg=Default,
		.buf=std.slalloc((ws.row * ws.col : std.size)),
		.cursor=false
	])
	std.slfill(t.buf, [.chr=' ', .attr=Normal, .fg=Default, .bg=Default])
	tcgetattr(t.fd, &t.orig)
	cls(t);
	-> t
}

const raw = {t
	var tio

	tio = t.orig
	tio.iflag &= ~(Brkint | Icrnl | Inpck | Istrip | Ixon)
	tio.oflag &= ~termdraw.Opost
	tio.cflag |= termdraw.Cs8
	tio.lflag &= ~(Echo | Icanon | Iexten | Isig)
	tio.cc[termdraw.Vmin] = 0
	tio.cc[termdraw.Vtime] = 1
	tcsetattr(t.fd, `termdraw.Oflush, &tio)
	cursoroff(t)
}

const free = {t
	tcsetattr(t.fd, `termdraw.Oflush, &t.orig)
	std.fput(t.fd, "\x1bc")
	std.slfree(t.buf)
	std.free(t)
}

const cls = {t
	std.slfill(t.buf, [.chr=' ', .attr=Normal, .fg=Default, .bg=Default])
	std.fput(t.fd, "\x1b[2J")
	move(t, 0, 0)
}

const clear = {t, x0, y0, x1, y1
	var x, y

	x0 = std.clamp(x0, 0, t.width)
	y0 = std.clamp(y0, 0, t.height)
	x1 = std.clamp(x1, 0, t.width)
	y1 = std.clamp(y1, 0, t.height)

	if x0 > x1
		std.swap(&x0, &x1)
	;;
	if y0 > y1
		std.swap(&y0, &y1)
	;;

	for y = y0; y != y1; y++
		for x = x0; x != x1; x++
			t.buf[y*t.width + x].bg = t.bg
			t.buf[y*t.width + x].fg = t.fg
			t.buf[y*t.width + x].chr = ' '
		;;
	;;

}

const flush = {t
	var fg, bg, attr, len
	var sb, s

	fg = -1
	bg = -1
	attr = -1
	sb = std.mksb()

	/* hide cursor, move to top, and draw everything */
	std.sbfmt(sb, "\x1b[?25l")
	std.sbfmt(sb, "\x1b[1;1f")
	for var i = 0; i < t.width * t.height; i++
		if attr != t.buf[i].attr
			attr = t.buf[i].attr;
			std.sbfmt(sb, "\x1b[{}m", attr)
		;;
		if fg != t.buf[i].fg
			fg = t.buf[i].fg;
			std.sbfmt(sb, "\x1b[{}m", 30+fg)
		;;
		if bg != t.buf[i].bg
			bg = t.buf[i].bg;
			std.sbfmt(sb, "\x1b[{}m", 40+bg)
		;;
		std.sbputc(sb, t.buf[i].chr)
		if i % t.width == t.width - 1 && i != t.width * t.height - 1
			std.sbfmt(sb, "\r\n")
		;;
	;;
	/* restore cursor state */
	std.sbfmt(sb, "\x1b[{};{}f", t.cy + 1, t.cx + 1)
	if t.cursor
		std.sbfmt(sb, "\x1b[?25h")
	;;

	len = 0
	s = std.sbfin(sb)
	while len != s.len
		match std.write(t.fd, s[len:])
		| `std.Ok 0:	break
		| `std.Ok n:	len += n
		| `std.Err e:	std.fatal("could not flush: {}\n", e)
		;;
	;;
	std.slfree(s)
}

const resize = {t, x, y
	var buf
	var w, h

	w = std.min(x, t.width)
	h = std.min(y, t.height)

	buf=std.slalloc((x* y : std.size))
	std.slfill(buf, [.chr=' ', .attr=t.attr, .fg=t.fg, .bg=t.bg])
	for var i = 0; i < h; i++
		std.slcp(buf[x*i : x*i + w], t.buf[t.width *i:t.width*i + w])
	;;
	std.slfree(t.buf)
	t.width = x
	t.height = y
	t.buf = buf
	flush(t)
}

const size = {t
	-> (t.width, t.height)
}

const move = {t, x, y
	t.x = x
	t.y = y
}

const cursorpos = {t, x, y
	t.cx = x
	t.cy = y
}

const cursoroff = {t
	t.cursor = false
}

const cursoron = {t
	t.cursor = true
}

const putc = {t, c
	var idx
	
	idx = t.y * t.width + t.x
	if idx >= t.buf.len
		-> void
	;;
	match c
	| '\r':	t.x = 0
	| '\n': t.y = std.min(t.y + 1, t.height)
	| '\t':
		for var i = 0; i < 8; i++
			putc(t, ' ')
		;;
	| chr:
		t.buf[idx].chr = chr
		t.buf[idx].fg = t.fg
		t.buf[idx].bg = t.bg
		t.buf[idx].attr = t.attr

		if t.x > t.width
			t.y++ 
		;;
		t.x = (t.x + 1) % t.width
	;;
}

const put = {t, fmt, args
	var s, ap

	ap = std.vastart(&args)
	s = std.fmtv(fmt, &ap)
	for c in std.bychar(s)
		putc(t, c)
	;;
	std.slfree(s)
}

const setattr = {t, attr
	t.attr = attr
}

const setfg = {t, fg
	t.fg = fg
}

const setbg = {t, bg
	t.bg = bg
}
