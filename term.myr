use std

use "types"
use "termios"
use "tiparse"
use "tiprops"

pkg termdraw =
	const Black	: color = 0
	const Red  	: color = 1
	const Green	: color = 2
	const Yellow	: color = 3
	const Blue 	: color = 4
	const Magenta	: color = 5
	const Cyan 	: color = 6
	const White	: color = 7
	const Default	: color = 9

	const Normal	: attr = 0
	const Bold	: attr = 1
	const Italic	: attr = 3
	const Underline	: attr = 4
	const Blink	: attr = 5
	const Invert	: attr = 7


	const mk	: (fd : std.fd -> term#)
	const free	: (t : term# -> void)
	const raw	: (t : term# -> void)

	const size	: (t : term# -> (int, int))
	const move	: (t : term#, r : int, c : int -> void)
	const cursorpos	: (t : term#, r : int, c : int -> void)
	const cursoroff	: (t : term# -> void)
	const cursoron	: (t : term# -> void)

	const strwidth	: (t : term#, str : byte[:] -> int)

	const cls	: (t : term# -> void)
	const clear	: (t : term#, x0 : int, y0 : int, x1 : int, y1 : int -> void)
	const flush	: (t : term# -> void)
	const putc	: (t : term#, c : char -> void)
	const put	: (t : term#, fmt : byte[:], args : ... -> void)
	const setfg	: (t : term#, c : color -> void)
	const setbg	: (t : term#, c : color -> void)
	const setattr	: (t : term#, c : attr -> void)

	pkglocal const resize	: (t : term#, x : int, y : int -> void)
;;


const mk = {fd
	var ws, t, name

	tcwinsize(fd, &ws)
	t = std.mk([
		.fd=fd,
		.x=0,
		.y=0,
		.width=(ws.col : int),
		.height=(ws.row: int),
		.fg=Default,
		.bg=Default,
		.buf=std.slalloc((ws.row * ws.col : std.size)),
		.cursor=false
	])
	name = std.getenvv("TERM", "vt100")
	match tiparse(name)
	| `std.Ok inf:	t.info = inf
	| `std.Err e:	/* whatevs */
	;;
	addevents(t)
	std.slfill(t.buf, [.chr=' ', .attr=Normal, .fg=Default, .bg=Default])
	tcgetattr(t.fd, &t.orig)
	cls(t);
	-> t
}

const addevents = {t
	var s : byte[1]
	t.kesc = std.zalloc()
	/* single byte chars default to themselves */
	for var i = 0; i < 128; i++
		s[0] = (i : byte)
		if i < 0x1f
			addevent(t, -1, s[:], `Ctrl (i | 0x60))
		else
			addevent(t, -1, s[:], `Kc i)
		;;
	;;
	/* hard coded overrides */
	addevent(t, -1, "\x1b", `Kesc)
	addevent(t, -1, "\r", `Kc '\n')
	addevent(t, -1, "\t", `Kc '\t')
	addevent(t, -1, "\x1b[A", `Kup)
	addevent(t, -1, "\x1b[B", `Kdown)
	addevent(t, -1, "\x1b[C", `Kleft)
	addevent(t, -1, "\x1b[D", `Kright)

	/* keys from terminfo */
	addevent(t, Key_backspace, "\b", `Kbksp)
	addevent(t, Delete_character, "\x1b[~3", `Kdel)
	addevent(t, Tab, "\x09", `Kc '\t')
	addevent(t, Key_npage, "", `Kpgdn)
	addevent(t, Key_ppage, "", `Kpgup)
	addevent(t, Key_home, "\x1b0H", `Khome)
	addevent(t, Key_end, "\x1b0F", `Kend)
	addevent(t, Key_f1, "", `Kf1)
	addevent(t, Key_f2, "", `Kf2)
	addevent(t, Key_f3, "", `Kf3)
	addevent(t, Key_f4, "", `Kf4)
	addevent(t, Key_f5, "", `Kf5)
	addevent(t, Key_f6, "", `Kf6)
	addevent(t, Key_f7, "", `Kf7)
	addevent(t, Key_f8, "", `Kf8)
	addevent(t, Key_f9, "", `Kf9)
	addevent(t, Key_f10, "", `Kf10)
	addevent(t, Key_f11, "", `Kf11)
}

const addevent = {t, key, fallback, ev
	var seq, n, nn

	seq = std.getv(tigetstr(&t.info, key), fallback)
	if seq.len == 0
		-> void
	;;
	std.put("seq: {}, ev: {}\n", seq, ev)
	n = t.kesc
	for b : seq
		match n.sub[b]
		| `std.Some et:	nn = et
		| `std.None:	nn = std.zalloc()
		;;
		n.sub[b] = `std.Some nn
		n = nn
	;;
	n.ev = ev
	std.put("{e}\n", seq)
}

const raw = {t
	var tio

	tio = t.orig
	tio.iflag &= ~(Brkint | Icrnl | Inpck | Istrip | Ixon)
	tio.oflag &= ~termdraw.Opost
	tio.cflag |= termdraw.Cs8
	tio.lflag &= ~(Echo | Icanon | Iexten | Isig)
	tio.cc[termdraw.Vmin] = 0
	tio.cc[termdraw.Vtime] = 1
	tcsetattr(t.fd, `termdraw.Oflush, &tio)
	cursoroff(t)
}

const free = {t
	tcsetattr(t.fd, `termdraw.Oflush, &t.orig)
	std.fput(t.fd, "\x1bc")
	std.slfree(t.buf)
	std.free(t)
}

const cls = {t
	std.slfill(t.buf, [.chr=' ', .attr=Normal, .fg=Default, .bg=Default])
	std.fput(t.fd, "\x1b[2J")
	move(t, 0, 0)
}

const clear = {t, x0, y0, x1, y1
	var x, y

	x0 = std.clamp(x0, 0, t.width)
	y0 = std.clamp(y0, 0, t.height)
	x1 = std.clamp(x1, 0, t.width)
	y1 = std.clamp(y1, 0, t.height)

	if x0 > x1
		std.swap(&x0, &x1)
	;;
	if y0 > y1
		std.swap(&y0, &y1)
	;;

	for y = y0; y != y1; y++
		for x = x0; x != x1; x++
			t.buf[y*t.width + x].bg = t.bg
			t.buf[y*t.width + x].fg = t.fg
			t.buf[y*t.width + x].chr = ' '
		;;
	;;

}

const flush = {t
	var fg, bg, attr, len
	var sb, s

	fg = -1
	bg = -1
	attr = -1
	sb = std.mksb()

	/* hide cursor, move to top, and draw everything */
	std.sbfmt(sb, "\x1b[?25l")
	std.sbfmt(sb, "\x1b[1;1f")
	for var i = 0; i < t.width * t.height; i++
		if attr != t.buf[i].attr
			attr = t.buf[i].attr;
			std.sbfmt(sb, "\x1b[{}m", attr)
		;;
		if fg != t.buf[i].fg
			fg = t.buf[i].fg;
			std.sbfmt(sb, "\x1b[{}m", 30+fg)
		;;
		if bg != t.buf[i].bg
			bg = t.buf[i].bg;
			std.sbfmt(sb, "\x1b[{}m", 40+bg)
		;;
		std.sbputc(sb, t.buf[i].chr)
		if i % t.width == t.width - 1 && i != t.width * t.height - 1
			std.sbfmt(sb, "\r\n")
		;;
	;;
	/* restore cursor state */
	std.sbfmt(sb, "\x1b[{};{}f", t.cy + 1, t.cx + 1)
	if t.cursor
		std.sbfmt(sb, "\x1b[?25h")
	;;

	len = 0
	s = std.sbfin(sb)
	while len != s.len
		match std.write(t.fd, s[len:])
		| `std.Ok 0:	break
		| `std.Ok n:	len += n
		| `std.Err e:	std.fatal("could not flush: {}\n", e)
		;;
	;;
	std.slfree(s)
}

const resize = {t, x, y
	var buf
	var w, h

	w = std.min(x, t.width)
	h = std.min(y, t.height)

	buf=std.slalloc((x* y : std.size))
	std.slfill(buf, [.chr=' ', .attr=t.attr, .fg=t.fg, .bg=t.bg])
	for var i = 0; i < h; i++
		std.slcp(buf[x*i : x*i + w], t.buf[t.width *i:t.width*i + w])
	;;
	std.slfree(t.buf)
	t.width = x
	t.height = y
	t.buf = buf
	flush(t)
}

const size = {t
	-> (t.width, t.height)
}

const move = {t, x, y
	t.x = x
	t.y = y
}

const cursorpos = {t, x, y
	t.cx = x
	t.cy = y
}

const cursoroff = {t
	t.cursor = false
}

const cursoron = {t
	t.cursor = true
}

const strwidth = {t, str
	var x0, x

	x = t.x
	x0 = t.x
	for c : std.bychar(str)
		match c
		| '\t':	x = (x / 8 + 1)*8
		| '\n':	/* ignore */
		| chr:	x++
		;;
	;;
	-> x - x0
}

const putc = {t, c
	var idx
	
	if t.x >= t.width || t.y >= t.height
		-> void
	;;

	idx = t.y * t.width + t.x
	match c
	| '\r':	t.x = 0
	| '\n': t.y = std.min(t.y + 1, t.height)
	| '\t':
		for var i = 0; i < 8; i++
			putc(t, ' ')
		;;
	| chr:
		t.buf[idx].chr = chr
		t.buf[idx].fg = t.fg
		t.buf[idx].bg = t.bg
		t.buf[idx].attr = t.attr

		if t.x > t.width
			t.y++ 
		;;
		t.x = (t.x + 1) % t.width
	;;
}

const put = {t, fmt, args
	var s, ap

	ap = std.vastart(&args)
	s = std.fmtv(fmt, &ap)
	for c : std.bychar(s)
		putc(t, c)
	;;
	std.slfree(s)
}

const setattr = {t, attr
	t.attr = attr
}

const setfg = {t, fg
	t.fg = fg
}

const setbg = {t, bg
	t.bg = bg
}
